# Complex Form Pattern

This project utilizes a pattern for creating complex forms that emphasizes clear separation of concerns and leverages Prisma-generated types for data integrity.

## Core Principles

- **Server-Side Data Fetching and Mutations:** Data fetching for initial form population and form mutations (create/update) are handled on the server-side, often within API routes or server actions. This keeps business logic off the client.
- **Client-Side Form Management:** The client component (`content.tsx` or the component within `page.tsx` for simpler cases) is responsible for managing form state, handling user input, and validation.
- **Prisma Types for Structure and Validation:** Types generated by Prisma are used to define the structure of the data being handled by the form. This provides strong typing and helps ensure that the form data aligns with the database schema.
- **Explicit Prop Passing:** Form handlers (functions for submission, validation, etc.) and form state are passed down as props to child components. This makes data flow explicit and components more reusable.
- **Component Composition:** Complex forms are broken down into smaller, manageable components, each responsible for a specific part of the form.

## Implementation Details

Let's look at `components/domains/email-account-form.tsx` as an example:

- **Prisma Types:** The form likely interacts with data corresponding to an email account. Prisma's type generation would provide a type definition for an email account (e.g., `EmailAccount`). This type is used within the form component to define the expected structure of the form data and potentially for validation.

- **Form Handlers and State:**
    - The component will manage the form's state using hooks like `useState` or a form library. This state will hold the current values of the form fields.
    - Functions for handling form submission (`onSubmit`), input changes (`onChange`), and potentially validation logic are defined within the component.
    - These handlers and the current form state are passed down as props to the individual input components or sections of the form.

- **Complex Scenarios:** In complex forms with nested data or conditional fields, this pattern is particularly useful. Child components responsible for specific sections of the form receive the relevant slice of the form state and the necessary handlers as props. This prevents the main form component from becoming overly complex.

- **Example in `email-account-form.tsx`:** You would expect to see:
    - State variables holding the email account's properties (e.g., email address, password, server details).
    - An `onSubmit` function that takes the form data, potentially performs client-side validation, and then calls a server action or API route to save the data.
    - Input components for each field, receiving the current value from the state and an `onChange` handler to update the state.
    - Potentially conditional rendering of fields based on other form values, with the logic managed within the component and state updates triggering re-renders.

By adhering to this pattern, forms remain maintainable, testable, and the separation of concerns between server and client is clear. The use of Prisma types further enhances type safety and aligns the form with the data model.